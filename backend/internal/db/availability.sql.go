// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: availability.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createAvailability = `-- name: CreateAvailability :exec
INSERT INTO availability (id, provider_id, start_time, end_time)
VALUES (
    uuid(),
    uuid(),
    ?,
    ?
)
`

type CreateAvailabilityParams struct {
	StartTime time.Time
	EndTime   time.Time
}

func (q *Queries) CreateAvailability(ctx context.Context, arg CreateAvailabilityParams) error {
	_, err := q.db.ExecContext(ctx, createAvailability, arg.StartTime, arg.EndTime)
	return err
}

const deleteAvailability = `-- name: DeleteAvailability :exec
DELETE FROM availability WHERE id = ?
`

func (q *Queries) DeleteAvailability(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAvailability, id)
	return err
}

const listAllFreeSlots = `-- name: ListAllFreeSlots :many
SELECT
s.id,
s.start_time,
s.end_time
FROM availability AS s
LEFT JOIN bookings AS b
  ON b.slot_id = s.id
WHERE b.slot_id is NULL
  AND s.provider_id = ?
  AND s.start_time >= ?
  AND s.end_time <= ?
ORDER BY s.start_time
`

type ListAllFreeSlotsParams struct {
	ProviderID uuid.UUID
	StartTime  time.Time
	EndTime    time.Time
}

type ListAllFreeSlotsRow struct {
	ID        uuid.UUID
	StartTime time.Time
	EndTime   time.Time
}

func (q *Queries) ListAllFreeSlots(ctx context.Context, arg ListAllFreeSlotsParams) ([]ListAllFreeSlotsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllFreeSlots, arg.ProviderID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllFreeSlotsRow
	for rows.Next() {
		var i ListAllFreeSlotsRow
		if err := rows.Scan(&i.ID, &i.StartTime, &i.EndTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAvailabilityByProvider = `-- name: ListAvailabilityByProvider :many
SELECT
  id,
  provider_id,
  start_time,
  end_time,
  created_at,
  updated_at
FROM availability
WHERE provider_id = ? ORDER BY start_time
`

func (q *Queries) ListAvailabilityByProvider(ctx context.Context, providerID uuid.UUID) ([]Availability, error) {
	rows, err := q.db.QueryContext(ctx, listAvailabilityByProvider, providerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Availability
	for rows.Next() {
		var i Availability
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.StartTime,
			&i.EndTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAvailabilityInRange = `-- name: ListAvailabilityInRange :many
SELECT
  id,
  provider_id,
  start_time,
  end_time
FROM availability
WHERE provider_id = ?
AND start_time >= ?
AND end_time <= ?
ORDER BY start_time
`

type ListAvailabilityInRangeParams struct {
	ProviderID uuid.UUID
	StartTime  time.Time
	EndTime    time.Time
}

type ListAvailabilityInRangeRow struct {
	ID         uuid.UUID
	ProviderID uuid.UUID
	StartTime  time.Time
	EndTime    time.Time
}

func (q *Queries) ListAvailabilityInRange(ctx context.Context, arg ListAvailabilityInRangeParams) ([]ListAvailabilityInRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, listAvailabilityInRange, arg.ProviderID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAvailabilityInRangeRow
	for rows.Next() {
		var i ListAvailabilityInRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.ProviderID,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
